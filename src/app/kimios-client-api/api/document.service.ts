/**
 * Kimios API
 * Kimios Sample API
 *
 * OpenAPI spec version: 1.2.2-SNAPSHOT - 282608d038dbfdf7754fa4e049f180f36e0f635a
 * Contact: documentation@kimios.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { Bookmark } from '../model/bookmark';
import { Document } from '../model/document';
import { InputStream } from '../model/inputStream';
import { SymbolicLink } from '../model/symbolicLink';
import { WorkflowStatus } from '../model/workflowStatus';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DocumentService {

    protected basePath = 'http://localhost/rest/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param sessionId 
     * @param dmEntityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addBookmark(sessionId?: string, dmEntityId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addBookmark(sessionId?: string, dmEntityId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addBookmark(sessionId?: string, dmEntityId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addBookmark(sessionId?: string, dmEntityId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (dmEntityId !== undefined && dmEntityId !== null) {
            queryParameters = queryParameters.set('dmEntityId', <any>dmEntityId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/addBookmark`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param dmEntityId 
     * @param groupId 
     * @param groupSource 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addGroupBookmark(sessionId?: string, dmEntityId?: number, groupId?: string, groupSource?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addGroupBookmark(sessionId?: string, dmEntityId?: number, groupId?: string, groupSource?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addGroupBookmark(sessionId?: string, dmEntityId?: number, groupId?: string, groupSource?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addGroupBookmark(sessionId?: string, dmEntityId?: number, groupId?: string, groupSource?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (dmEntityId !== undefined && dmEntityId !== null) {
            queryParameters = queryParameters.set('dmEntityId', <any>dmEntityId);
        }
        if (groupId !== undefined && groupId !== null) {
            queryParameters = queryParameters.set('groupId', <any>groupId);
        }
        if (groupSource !== undefined && groupSource !== null) {
            queryParameters = queryParameters.set('groupSource', <any>groupSource);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/addGroupBookmark`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param relatedDocumentUid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addRelatedDocument(sessionId?: string, documentId?: number, relatedDocumentUid?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addRelatedDocument(sessionId?: string, documentId?: number, relatedDocumentUid?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addRelatedDocument(sessionId?: string, documentId?: number, relatedDocumentUid?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addRelatedDocument(sessionId?: string, documentId?: number, relatedDocumentUid?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (documentId !== undefined && documentId !== null) {
            queryParameters = queryParameters.set('documentId', <any>documentId);
        }
        if (relatedDocumentUid !== undefined && relatedDocumentUid !== null) {
            queryParameters = queryParameters.set('relatedDocumentUid', <any>relatedDocumentUid);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/addRelatedDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param name 
     * @param dmEntityId 
     * @param parentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addSymbolicLink(sessionId?: string, name?: string, dmEntityId?: number, parentId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addSymbolicLink(sessionId?: string, name?: string, dmEntityId?: number, parentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addSymbolicLink(sessionId?: string, name?: string, dmEntityId?: number, parentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addSymbolicLink(sessionId?: string, name?: string, dmEntityId?: number, parentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (dmEntityId !== undefined && dmEntityId !== null) {
            queryParameters = queryParameters.set('dmEntityId', <any>dmEntityId);
        }
        if (parentId !== undefined && parentId !== null) {
            queryParameters = queryParameters.set('parentId', <any>parentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/addSymbolicLink`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkinDocument(sessionId?: string, documentId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public checkinDocument(sessionId?: string, documentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public checkinDocument(sessionId?: string, documentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public checkinDocument(sessionId?: string, documentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (documentId !== undefined && documentId !== null) {
            queryParameters = queryParameters.set('documentId', <any>documentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/checkinDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkoutDocument(sessionId?: string, documentId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public checkoutDocument(sessionId?: string, documentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public checkoutDocument(sessionId?: string, documentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public checkoutDocument(sessionId?: string, documentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (documentId !== undefined && documentId !== null) {
            queryParameters = queryParameters.set('documentId', <any>documentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/checkoutDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param sourceDocumentId 
     * @param documentCopyName 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public copyDocument(sessionId?: string, sourceDocumentId?: number, documentCopyName?: string, observe?: 'body', reportProgress?: boolean): Observable<Document>;
    public copyDocument(sessionId?: string, sourceDocumentId?: number, documentCopyName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Document>>;
    public copyDocument(sessionId?: string, sourceDocumentId?: number, documentCopyName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Document>>;
    public copyDocument(sessionId?: string, sourceDocumentId?: number, documentCopyName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (sourceDocumentId !== undefined && sourceDocumentId !== null) {
            queryParameters = queryParameters.set('sourceDocumentId', <any>sourceDocumentId);
        }
        if (documentCopyName !== undefined && documentCopyName !== null) {
            queryParameters = queryParameters.set('documentCopyName', <any>documentCopyName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Document>(`${this.basePath}/document/copyDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param name 
     * @param extension 
     * @param mimeType 
     * @param folderId 
     * @param isSecurityInherited 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDocument(sessionId?: string, name?: string, extension?: string, mimeType?: string, folderId?: number, isSecurityInherited?: boolean, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public createDocument(sessionId?: string, name?: string, extension?: string, mimeType?: string, folderId?: number, isSecurityInherited?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public createDocument(sessionId?: string, name?: string, extension?: string, mimeType?: string, folderId?: number, isSecurityInherited?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public createDocument(sessionId?: string, name?: string, extension?: string, mimeType?: string, folderId?: number, isSecurityInherited?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (extension !== undefined && extension !== null) {
            queryParameters = queryParameters.set('extension', <any>extension);
        }
        if (mimeType !== undefined && mimeType !== null) {
            queryParameters = queryParameters.set('mimeType', <any>mimeType);
        }
        if (folderId !== undefined && folderId !== null) {
            queryParameters = queryParameters.set('folderId', <any>folderId);
        }
        if (isSecurityInherited !== undefined && isSecurityInherited !== null) {
            queryParameters = queryParameters.set('isSecurityInherited', <any>isSecurityInherited);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<number>(`${this.basePath}/document/createDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param path 
     * @param isSecurityInherited 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDocumentFromFullPath(sessionId?: string, path?: string, isSecurityInherited?: boolean, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public createDocumentFromFullPath(sessionId?: string, path?: string, isSecurityInherited?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public createDocumentFromFullPath(sessionId?: string, path?: string, isSecurityInherited?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public createDocumentFromFullPath(sessionId?: string, path?: string, isSecurityInherited?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }
        if (isSecurityInherited !== undefined && isSecurityInherited !== null) {
            queryParameters = queryParameters.set('isSecurityInherited', <any>isSecurityInherited);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<number>(`${this.basePath}/document/createDocumentFromFullPath`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param name 
     * @param extension 
     * @param isSecurityInherited 
     * @param securitiesXmlStream 
     * @param documentTypeId 
     * @param metasXmlStream 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDocumentFromFullPathAndVersion(sessionId?: string, name?: string, extension?: string, isSecurityInherited?: boolean, securitiesXmlStream?: string, documentTypeId?: number, metasXmlStream?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public createDocumentFromFullPathAndVersion(sessionId?: string, name?: string, extension?: string, isSecurityInherited?: boolean, securitiesXmlStream?: string, documentTypeId?: number, metasXmlStream?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public createDocumentFromFullPathAndVersion(sessionId?: string, name?: string, extension?: string, isSecurityInherited?: boolean, securitiesXmlStream?: string, documentTypeId?: number, metasXmlStream?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public createDocumentFromFullPathAndVersion(sessionId?: string, name?: string, extension?: string, isSecurityInherited?: boolean, securitiesXmlStream?: string, documentTypeId?: number, metasXmlStream?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (extension !== undefined && extension !== null) {
            queryParameters = queryParameters.set('extension', <any>extension);
        }
        if (isSecurityInherited !== undefined && isSecurityInherited !== null) {
            queryParameters = queryParameters.set('isSecurityInherited', <any>isSecurityInherited);
        }
        if (securitiesXmlStream !== undefined && securitiesXmlStream !== null) {
            queryParameters = queryParameters.set('securitiesXmlStream', <any>securitiesXmlStream);
        }
        if (documentTypeId !== undefined && documentTypeId !== null) {
            queryParameters = queryParameters.set('documentTypeId', <any>documentTypeId);
        }
        if (metasXmlStream !== undefined && metasXmlStream !== null) {
            queryParameters = queryParameters.set('metasXmlStream', <any>metasXmlStream);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<number>(`${this.basePath}/document/createDocumentFromFullPathAndVersion`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param path 
     * @param isSecurityInherited 
     * @param securitiesXmlStream 
     * @param isRecursive 
     * @param documentTypeId 
     * @param metasXmlStream 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDocumentFromFullPathWithProperties(sessionId?: string, path?: string, isSecurityInherited?: boolean, securitiesXmlStream?: string, isRecursive?: boolean, documentTypeId?: number, metasXmlStream?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public createDocumentFromFullPathWithProperties(sessionId?: string, path?: string, isSecurityInherited?: boolean, securitiesXmlStream?: string, isRecursive?: boolean, documentTypeId?: number, metasXmlStream?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public createDocumentFromFullPathWithProperties(sessionId?: string, path?: string, isSecurityInherited?: boolean, securitiesXmlStream?: string, isRecursive?: boolean, documentTypeId?: number, metasXmlStream?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public createDocumentFromFullPathWithProperties(sessionId?: string, path?: string, isSecurityInherited?: boolean, securitiesXmlStream?: string, isRecursive?: boolean, documentTypeId?: number, metasXmlStream?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }
        if (isSecurityInherited !== undefined && isSecurityInherited !== null) {
            queryParameters = queryParameters.set('isSecurityInherited', <any>isSecurityInherited);
        }
        if (securitiesXmlStream !== undefined && securitiesXmlStream !== null) {
            queryParameters = queryParameters.set('securitiesXmlStream', <any>securitiesXmlStream);
        }
        if (isRecursive !== undefined && isRecursive !== null) {
            queryParameters = queryParameters.set('isRecursive', <any>isRecursive);
        }
        if (documentTypeId !== undefined && documentTypeId !== null) {
            queryParameters = queryParameters.set('documentTypeId', <any>documentTypeId);
        }
        if (metasXmlStream !== undefined && metasXmlStream !== null) {
            queryParameters = queryParameters.set('metasXmlStream', <any>metasXmlStream);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        return this.httpClient.post<number>(`${this.basePath}/document/createDocumentFromFullPathWithProperties`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param document 
     * @param sessionId 
     * @param path 
     * @param isSecurityInherited 
     * @param securityItems 
     * @param isRecursive 
     * @param documentTypeId 
     * @param metaItems 
     * @param md5 
     * @param sha1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDocumentFromFullPathWithPropertiesNoHash(document: File, sessionId?: string, path?: string, isSecurityInherited?: boolean, securityItems?: string, isRecursive?: boolean, documentTypeId?: number, metaItems?: string, md5?: string, sha1?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public createDocumentFromFullPathWithPropertiesNoHash(document: File, sessionId?: string, path?: string, isSecurityInherited?: boolean, securityItems?: string, isRecursive?: boolean, documentTypeId?: number, metaItems?: string, md5?: string, sha1?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public createDocumentFromFullPathWithPropertiesNoHash(document: File, sessionId?: string, path?: string, isSecurityInherited?: boolean, securityItems?: string, isRecursive?: boolean, documentTypeId?: number, metaItems?: string, md5?: string, sha1?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public createDocumentFromFullPathWithPropertiesNoHash(document: File, sessionId?: string, path?: string, isSecurityInherited?: boolean, securityItems?: string, isRecursive?: boolean, documentTypeId?: number, metaItems?: string, md5?: string, sha1?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (document === null || document === undefined) {
            throw new Error('Required parameter document was null or undefined when calling createDocumentFromFullPathWithPropertiesNoHash.');
        }

        const formData = new FormData();
        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (document !== undefined && document !== null) {
            queryParameters = queryParameters.set('document', <any>document);
            formData.append('document', document);
        }
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
            formData.append('sessionId', sessionId);
        }
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
            formData.append('path', path);
        }
        if (isSecurityInherited !== undefined && isSecurityInherited !== null) {
            queryParameters = queryParameters.set('isSecurityInherited', <any>isSecurityInherited);
            formData.append('isSecurityInherited', isSecurityInherited.toString());
        }
        if (isRecursive !== undefined && isRecursive !== null) {
            queryParameters = queryParameters.set('isRecursive', <any>isRecursive);
            formData.append('isRecursive', isRecursive.toString());
        }
        if (documentTypeId !== undefined && documentTypeId !== null) {
            queryParameters = queryParameters.set('documentTypeId', <any>documentTypeId);
            formData.append('documentTypeId', documentTypeId.toString());
        }
        if (securityItems !== undefined && securityItems !== null) {
            queryParameters = queryParameters.set('securityItems', <any>securityItems);
            formData.append('securityItems', securityItems);
        }
        if (metaItems !== undefined && metaItems !== null) {
            queryParameters = queryParameters.set('metaItems', <any>metaItems);
            formData.append('metaItems', metaItems);
        }
        if (metaItems !== undefined && metaItems !== null) {
            queryParameters = queryParameters.set('md5', <any>metaItems);
            formData.append('md5', md5);
        }
        if (metaItems !== undefined && metaItems !== null) {
            queryParameters = queryParameters.set('sha1', <any>metaItems);
            formData.append('sha1', sha1);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
//            'multipart/form-data'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/document/createDocumentFromFullPathWithPropertiesNoHash`,
            formData,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param name 
     * @param extension 
     * @param mimeType 
     * @param folderId 
     * @param isSecurityInherited 
     * @param securitiesXmlStream 
     * @param isRecursive 
     * @param documentTypeId 
     * @param metasXmlStream 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDocumentWithProperties(sessionId?: string, name?: string, extension?: string, mimeType?: string, folderId?: number, isSecurityInherited?: boolean, securitiesXmlStream?: string, isRecursive?: boolean, documentTypeId?: number, metasXmlStream?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public createDocumentWithProperties(sessionId?: string, name?: string, extension?: string, mimeType?: string, folderId?: number, isSecurityInherited?: boolean, securitiesXmlStream?: string, isRecursive?: boolean, documentTypeId?: number, metasXmlStream?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public createDocumentWithProperties(sessionId?: string, name?: string, extension?: string, mimeType?: string, folderId?: number, isSecurityInherited?: boolean, securitiesXmlStream?: string, isRecursive?: boolean, documentTypeId?: number, metasXmlStream?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public createDocumentWithProperties(sessionId?: string, name?: string, extension?: string, mimeType?: string, folderId?: number, isSecurityInherited?: boolean, securitiesXmlStream?: string, isRecursive?: boolean, documentTypeId?: number, metasXmlStream?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (extension !== undefined && extension !== null) {
            queryParameters = queryParameters.set('extension', <any>extension);
        }
        if (mimeType !== undefined && mimeType !== null) {
            queryParameters = queryParameters.set('mimeType', <any>mimeType);
        }
        if (folderId !== undefined && folderId !== null) {
            queryParameters = queryParameters.set('folderId', <any>folderId);
        }
        if (isSecurityInherited !== undefined && isSecurityInherited !== null) {
            queryParameters = queryParameters.set('isSecurityInherited', <any>isSecurityInherited);
        }
        if (securitiesXmlStream !== undefined && securitiesXmlStream !== null) {
            queryParameters = queryParameters.set('securitiesXmlStream', <any>securitiesXmlStream);
        }
        if (isRecursive !== undefined && isRecursive !== null) {
            queryParameters = queryParameters.set('isRecursive', <any>isRecursive);
        }
        if (documentTypeId !== undefined && documentTypeId !== null) {
            queryParameters = queryParameters.set('documentTypeId', <any>documentTypeId);
        }
        if (metasXmlStream !== undefined && metasXmlStream !== null) {
            queryParameters = queryParameters.set('metasXmlStream', <any>metasXmlStream);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        return this.httpClient.post<number>(`${this.basePath}/document/createDocumentWithProperties`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param force 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteDocument(sessionId?: string, documentId?: number, force?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteDocument(sessionId?: string, documentId?: number, force?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteDocument(sessionId?: string, documentId?: number, force?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteDocument(sessionId?: string, documentId?: number, force?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (documentId !== undefined && documentId !== null) {
            queryParameters = queryParameters.set('documentId', <any>documentId);
        }
        if (force !== undefined && force !== null) {
            queryParameters = queryParameters.set('force', <any>force);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/deleteDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param folderId 
     * @param sessionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public exportToCsv(folderId: number, sessionId?: string, observe?: 'body', reportProgress?: boolean): Observable<InputStream>;
    public exportToCsv(folderId: number, sessionId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InputStream>>;
    public exportToCsv(folderId: number, sessionId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InputStream>>;
    public exportToCsv(folderId: number, sessionId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling exportToCsv.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/csv'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];

        return this.httpClient.get<InputStream>(`${this.basePath}/document/get/${encodeURIComponent(String(folderId))}/csv`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBookmarks(sessionId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Bookmark>>;
    public getBookmarks(sessionId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Bookmark>>>;
    public getBookmarks(sessionId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Bookmark>>>;
    public getBookmarks(sessionId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Bookmark>>(`${this.basePath}/document/getBookmarks`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param path 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBookmarksInPath(sessionId?: string, path?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Bookmark>>;
    public getBookmarksInPath(sessionId?: string, path?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Bookmark>>>;
    public getBookmarksInPath(sessionId?: string, path?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Bookmark>>>;
    public getBookmarksInPath(sessionId?: string, path?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Bookmark>>(`${this.basePath}/document/getBookmarksInPath`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param parentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChildSymbolicLinks(sessionId?: string, parentId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<SymbolicLink>>;
    public getChildSymbolicLinks(sessionId?: string, parentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SymbolicLink>>>;
    public getChildSymbolicLinks(sessionId?: string, parentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SymbolicLink>>>;
    public getChildSymbolicLinks(sessionId?: string, parentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (parentId !== undefined && parentId !== null) {
            queryParameters = queryParameters.set('parentId', <any>parentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SymbolicLink>>(`${this.basePath}/document/getChildSymbolicLinks`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDocument(sessionId?: string, documentId?: number, observe?: 'body', reportProgress?: boolean): Observable<Document>;
    public getDocument(sessionId?: string, documentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Document>>;
    public getDocument(sessionId?: string, documentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Document>>;
    public getDocument(sessionId?: string, documentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (documentId !== undefined && documentId !== null) {
            queryParameters = queryParameters.set('documentId', <any>documentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Document>(`${this.basePath}/document/getDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param folderId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDocuments(sessionId?: string, folderId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Document>>;
    public getDocuments(sessionId?: string, folderId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Document>>>;
    public getDocuments(sessionId?: string, folderId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Document>>>;
    public getDocuments(sessionId?: string, folderId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (folderId !== undefined && folderId !== null) {
            queryParameters = queryParameters.set('folderId', <any>folderId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Document>>(`${this.basePath}/document/getDocuments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLastWorkflowStatus(sessionId?: string, documentId?: number, observe?: 'body', reportProgress?: boolean): Observable<WorkflowStatus>;
    public getLastWorkflowStatus(sessionId?: string, documentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WorkflowStatus>>;
    public getLastWorkflowStatus(sessionId?: string, documentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WorkflowStatus>>;
    public getLastWorkflowStatus(sessionId?: string, documentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (documentId !== undefined && documentId !== null) {
            queryParameters = queryParameters.set('documentId', <any>documentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<WorkflowStatus>(`${this.basePath}/document/getLastWorkflowStatus`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMyCheckedOutDocuments(sessionId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Document>>;
    public getMyCheckedOutDocuments(sessionId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Document>>>;
    public getMyCheckedOutDocuments(sessionId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Document>>>;
    public getMyCheckedOutDocuments(sessionId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Document>>(`${this.basePath}/document/getMyCheckedOutDocuments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRecentItems(sessionId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Bookmark>>;
    public getRecentItems(sessionId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Bookmark>>>;
    public getRecentItems(sessionId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Bookmark>>>;
    public getRecentItems(sessionId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Bookmark>>(`${this.basePath}/document/getRecentItems`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRelatedDocuments(sessionId?: string, documentId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Document>>;
    public getRelatedDocuments(sessionId?: string, documentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Document>>>;
    public getRelatedDocuments(sessionId?: string, documentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Document>>>;
    public getRelatedDocuments(sessionId?: string, documentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (documentId !== undefined && documentId !== null) {
            queryParameters = queryParameters.set('documentId', <any>documentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Document>>(`${this.basePath}/document/getRelatedDocuments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param targetId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSymbolicLinksCreated(sessionId?: string, targetId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<SymbolicLink>>;
    public getSymbolicLinksCreated(sessionId?: string, targetId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SymbolicLink>>>;
    public getSymbolicLinksCreated(sessionId?: string, targetId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SymbolicLink>>>;
    public getSymbolicLinksCreated(sessionId?: string, targetId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (targetId !== undefined && targetId !== null) {
            queryParameters = queryParameters.set('targetId', <any>targetId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SymbolicLink>>(`${this.basePath}/document/getSymbolicLinksCreated`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param dmEntityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeBookmark(sessionId?: string, dmEntityId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeBookmark(sessionId?: string, dmEntityId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeBookmark(sessionId?: string, dmEntityId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeBookmark(sessionId?: string, dmEntityId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (dmEntityId !== undefined && dmEntityId !== null) {
            queryParameters = queryParameters.set('dmEntityId', <any>dmEntityId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/removeBookmark`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param dmEntityId 
     * @param groupId 
     * @param groupSource 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeGroupBookmark(sessionId?: string, dmEntityId?: number, groupId?: string, groupSource?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeGroupBookmark(sessionId?: string, dmEntityId?: number, groupId?: string, groupSource?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeGroupBookmark(sessionId?: string, dmEntityId?: number, groupId?: string, groupSource?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeGroupBookmark(sessionId?: string, dmEntityId?: number, groupId?: string, groupSource?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (dmEntityId !== undefined && dmEntityId !== null) {
            queryParameters = queryParameters.set('dmEntityId', <any>dmEntityId);
        }
        if (groupId !== undefined && groupId !== null) {
            queryParameters = queryParameters.set('groupId', <any>groupId);
        }
        if (groupSource !== undefined && groupSource !== null) {
            queryParameters = queryParameters.set('groupSource', <any>groupSource);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/removeGroupBookmark`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param relatedDocumentUid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeRelatedDocument(sessionId?: string, documentId?: number, relatedDocumentUid?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeRelatedDocument(sessionId?: string, documentId?: number, relatedDocumentUid?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeRelatedDocument(sessionId?: string, documentId?: number, relatedDocumentUid?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeRelatedDocument(sessionId?: string, documentId?: number, relatedDocumentUid?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (documentId !== undefined && documentId !== null) {
            queryParameters = queryParameters.set('documentId', <any>documentId);
        }
        if (relatedDocumentUid !== undefined && relatedDocumentUid !== null) {
            queryParameters = queryParameters.set('relatedDocumentUid', <any>relatedDocumentUid);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/removeRelatedDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param dmEntityId 
     * @param parentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeSymbolicLink(sessionId?: string, dmEntityId?: number, parentId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeSymbolicLink(sessionId?: string, dmEntityId?: number, parentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeSymbolicLink(sessionId?: string, dmEntityId?: number, parentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeSymbolicLink(sessionId?: string, dmEntityId?: number, parentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (dmEntityId !== undefined && dmEntityId !== null) {
            queryParameters = queryParameters.set('dmEntityId', <any>dmEntityId);
        }
        if (parentId !== undefined && parentId !== null) {
            queryParameters = queryParameters.set('parentId', <any>parentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/removeSymbolicLink`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param name 
     * @param extension 
     * @param mimeType 
     * @param folderId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateDocument(sessionId?: string, documentId?: number, name?: string, extension?: string, mimeType?: string, folderId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateDocument(sessionId?: string, documentId?: number, name?: string, extension?: string, mimeType?: string, folderId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateDocument(sessionId?: string, documentId?: number, name?: string, extension?: string, mimeType?: string, folderId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateDocument(sessionId?: string, documentId?: number, name?: string, extension?: string, mimeType?: string, folderId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (documentId !== undefined && documentId !== null) {
            queryParameters = queryParameters.set('documentId', <any>documentId);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (extension !== undefined && extension !== null) {
            queryParameters = queryParameters.set('extension', <any>extension);
        }
        if (mimeType !== undefined && mimeType !== null) {
            queryParameters = queryParameters.set('mimeType', <any>mimeType);
        }
        if (folderId !== undefined && folderId !== null) {
            queryParameters = queryParameters.set('folderId', <any>folderId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/updateDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param tagId 
     * @param action 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateDocumentTag(sessionId: string, documentId: number, tagId?: number, action?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateDocumentTag(sessionId: string, documentId: number, tagId?: number, action?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateDocumentTag(sessionId: string, documentId: number, tagId?: number, action?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateDocumentTag(sessionId: string, documentId: number, tagId?: number, action?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (sessionId === null || sessionId === undefined) {
            throw new Error('Required parameter sessionId was null or undefined when calling updateDocumentTag.');
        }

        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling updateDocumentTag.');
        }

        if (tagId === null || tagId === undefined) {
            throw new Error('Required parameter tagId was null or undefined when calling updateDocumentTag.');
        }

        if (action === null || action === undefined) {
            throw new Error('Required parameter action was null or undefined when calling updateDocumentTag.');
        }

        const formData = new FormData();
        formData.append('sessionId', sessionId);
        formData.append('documentId', documentId.toString());
        formData.append('tagId', tagId.toString());
        formData.append('action', '' + action);

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
//            'multipart/form-data'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/document/updateDocumentTag`,
            formData,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param dmEntityId 
     * @param parentId 
     * @param newParentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSymbolicLink(sessionId?: string, dmEntityId?: number, parentId?: number, newParentId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateSymbolicLink(sessionId?: string, dmEntityId?: number, parentId?: number, newParentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateSymbolicLink(sessionId?: string, dmEntityId?: number, parentId?: number, newParentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateSymbolicLink(sessionId?: string, dmEntityId?: number, parentId?: number, newParentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sessionId !== undefined && sessionId !== null) {
            queryParameters = queryParameters.set('sessionId', <any>sessionId);
        }
        if (dmEntityId !== undefined && dmEntityId !== null) {
            queryParameters = queryParameters.set('dmEntityId', <any>dmEntityId);
        }
        if (parentId !== undefined && parentId !== null) {
            queryParameters = queryParameters.set('parentId', <any>parentId);
        }
        if (newParentId !== undefined && newParentId !== null) {
            queryParameters = queryParameters.set('newParentId', <any>newParentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/document/updateSymbolicLink`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param sessionId 
     * @param documentId 
     * @param document 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public uploadNewDocumentVersion(sessionId: string, documentId: number, document: File, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public uploadNewDocumentVersion(sessionId: string, documentId: number, document: File, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public uploadNewDocumentVersion(sessionId: string, documentId: number, document: File, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public uploadNewDocumentVersion(sessionId: string, documentId: number, document: File, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (sessionId === null || sessionId === undefined) {
            throw new Error('Required parameter sessionId was null or undefined when calling uploadNewDocumentVersion.');
        }

        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling uploadNewDocumentVersion.');
        }

        if (document === null || document === undefined) {
            throw new Error('Required parameter document was null or undefined when calling uploadNewDocumentVersion.');
        }

        const formData = new FormData();
        formData.append('sessionId', sessionId);
        formData.append('document', document);
        formData.append('documentId', documentId.toString());
        formData.append('md5', '');
        formData.append('sha1', '');

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            // 'multipart/form-data'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/document/uploadNewDocumentVersion`,
            formData,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
